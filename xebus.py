
import requests
import time
import math
import json
import os
from datetime import datetime, timedelta
from collections import defaultdict
import pytz

# =====================
# C·∫§U H√åNH
# =====================
BOT_TOKEN = "8489188807:AAFriXkC01MWLjCYfvfon46wlAe3oTBeXXY"

# C·∫•u h√¨nh 2 BOX ri√™ng bi·ªát
BOX_CONFIGS = {
    "box1": {
        "chat_id": "-4629872208",  # Group Box 1
        "name": "Box 1 - Tr·∫°m Ng√£ 4",
        "buon_don_stations": ["Tr·∫°m Ng√£ 4 Bu√¥n ƒê√¥n"],  # Ch·ªâ b√°o tr·∫°m Ng√£ 4
        "huyen_stations": ["Tr·∫°m Ng√£ T∆∞ Huy·ªán", "Tr·∫°m Ch·ª£ Huy·ªán"]  # B√°o ƒë·∫ßy ƒë·ªß ·ªü huy·ªán
    },
    "box2": {
        "chat_id": "-4983719802",  # Group Box 2  
        "name": "Box 2 - Tr·∫°m B∆∞u ƒêi·ªán",
        "buon_don_stations": ["Tr·∫°m B∆∞u ƒêi·ªán Bu√¥n ƒê√¥n"],  # Ch·ªâ b√°o tr·∫°m B∆∞u ƒêi·ªán
        "huyen_stations": ["Tr·∫°m Ng√£ T∆∞ Huy·ªán", "Tr·∫°m Ch·ª£ Huy·ªán"]  # B√°o ƒë·∫ßy ƒë·ªß ·ªü huy·ªán
    }
}

API_URL = "http://apigateway.vietnamcnn.vn/api/v2/vehicleonline/getlistvehicleonline"
HEADERS = {
    "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI4OTBlNWJmNmQ3ZDc0YjVkOWYxMzg5YWU1NmU5M2Q2MyIsInVuaXF1ZV9uYW1lIjoiODkwZTViZjZkN2Q3NGI1ZDlmMTM4OWFlNTZlOTNkNjMiLCJqdGkiOiIxZjZlODlmMi0yMmMyLTRmMWEtYmQ2My00NDU4MzUxNzA0YWEiLCJpYXQiOiIxNzU3NDIzNzE0MTc4IiwiaHR0cDovL3NjaGVtYXMueG1sc29hcC5vcmcvd3MvMjAwNS8wNS9pZGVudGl0eS9jbGFpbXMvbmFtZWlkZW50aWZpZXIiOiI4OTBlNWJmNi1kN2Q3LTRiNWQtOWYxMy04OWFlNTZlOTNkNjMiLCJGdWxsTmFtZSI6IkhUWCBWVCBIw6BuZyBIw7NhIEPGsCBNaWxsIiwidXNlcm5hbWUiOiJodHhjdW1pbGwiLCJwYXNzd29yZCI6IjEyMzQxMjM0IiwiQXZhdGFyVXJsIjoiaHR0cHM6Ly91cGxvYWRncHMuYmFncm91cC52bi9DTk4vQXZhdGFyL2F2YXRhcmRlZmF1bHQvYXZhdGFyX2RlZmF1bHQucG5nIiwibmJmIjoxNzU3NDIzNzE0LCJleHAiOjE3NTc1MTAxMTQsImlzcyI6IlRDVEdQU0lzc3VlciJ9.0SR3VlMq0S3abBUGEdTBkzFJEQ4Mw5TERZScPiEQshQ",
    "Content-Type": "application/json; charset=utf-8"
}
PAYLOAD = {
    "userID": "890e5bf6-d7d7-4b5d-9f13-89ae56e93d63",
    "companyID": 87575,
    "xnCode": 46705,
    "userType": 4,
    "companyType": 3,
    "appID": 4,
    "languageID": 1
}

# =====================
# TR·∫†M XE V√Ä D·ªÆ LI·ªÜU
# =====================
stations = {
    "Tr·∫°m B∆∞u ƒêi·ªán Bu√¥n ƒê√¥n": (12.87993, 107.79140),
    "Tr·∫°m Ng√£ 4 Bu√¥n ƒê√¥n": (12.89231, 107.78653),
    "Tr·∫°m Ng√£ T∆∞ Huy·ªán": (12.81124, 107.89504),
    "Tr·∫°m Ch·ª£ Huy·ªán": (12.80731, 107.89880)
}

# D·ªØ li·ªáu cache v√† th·ªëng k√™
vehicle_history = defaultdict(list)  # {plate: [(lat, lon, time), ...]}
user_favorites = {}  # {user_id: [station_names]}
daily_stats = defaultdict(int)  # Th·ªëng k√™ h√†ng ng√†y
notified = {}  # Tr√°nh spam
last_seen_vehicles = {}  # Theo d√µi xe cu·ªëi c√πng
pattern_data = defaultdict(list)  # H·ªçc patterns
last_update_id = 0  # Telegram update tracking

# =====================
# H√ÄM TI·ªÜN √çCH C·ªêT L√ïI
# =====================
def haversine(lat1, lon1, lat2, lon2):
    R = 6371  # km
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlambda = math.radians(lon2 - lon1)
    a = math.sin(dphi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(dlambda/2)**2
    return R * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))

def calculate_speed(plate, current_lat, current_lon, current_time):
    """T√≠nh t·ªëc ƒë·ªô di chuy·ªÉn c·ªßa xe"""
    if plate in vehicle_history and len(vehicle_history[plate]) > 0:
        last_record = vehicle_history[plate][-1]
        last_lat, last_lon, last_time = last_record
        
        distance = haversine(last_lat, last_lon, current_lat, current_lon)
        time_diff = (current_time - last_time).total_seconds() / 3600  # hours
        
        if time_diff > 0:
            speed = distance / time_diff  # km/h
            return min(speed, 100)  # Gi·ªõi h·∫°n t·ªëc ƒë·ªô t·ªëi ƒëa 100km/h
    return 0

def calculate_direction(lat1, lon1, lat2, lon2):
    """T√≠nh h∆∞·ªõng di chuy·ªÉn"""
    dlon = math.radians(lon2 - lon1)
    lat1, lat2 = math.radians(lat1), math.radians(lat2)
    
    y = math.sin(dlon) * math.cos(lat2)
    x = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(dlon)
    
    bearing = math.degrees(math.atan2(y, x))
    bearing = (bearing + 360) % 360
    
    directions = ["B·∫Øc", "ƒê√¥ng B·∫Øc", "ƒê√¥ng", "ƒê√¥ng Nam", "Nam", "T√¢y Nam", "T√¢y", "T√¢y B·∫Øc"]
    return directions[int((bearing + 22.5) / 45) % 8]

def estimate_arrival_time(plate, station_lat, station_lon):
    """D·ª± ƒëo√°n th·ªùi gian ƒë·∫øn tr·∫°m"""
    if plate in vehicle_history and len(vehicle_history[plate]) > 0:
        current_record = vehicle_history[plate][-1]
        current_lat, current_lon, current_time = current_record
        
        distance = haversine(current_lat, current_lon, station_lat, station_lon)
        speed = calculate_speed(plate, current_lat, current_lon, current_time)
        
        if speed > 5:  # N·∫øu xe ƒëang di chuy·ªÉn
            eta_hours = distance / speed
            eta_minutes = int(eta_hours * 60)
            return eta_minutes
    return None

def get_stations_to_check(box_config):
    """Tr·∫£ v·ªÅ c√°c tr·∫°m c·∫ßn ki·ªÉm tra theo khung gi·ªù, th·ª© trong tu·∫ßn v√† box c·ª• th·ªÉ"""
    tz = pytz.timezone("Asia/Ho_Chi_Minh")
    now_dt = datetime.now(tz)
    now = now_dt.time()
    weekday = now_dt.weekday()
    
    if weekday in [5, 6]:
        return {}, "Bot kh√¥ng ho·∫°t ƒë·ªông cu·ªëi tu·∫ßn"
    
    # 5h-6h: ch·ªâ b√°o tr·∫°m ri√™ng c·ªßa t·ª´ng box ·ªü Bu√¥n ƒê√¥n
    if now >= datetime.strptime("05:00", "%H:%M").time() and now <= datetime.strptime("06:00", "%H:%M").time():
        box_stations = {}
        for station_name in box_config["buon_don_stations"]:
            if station_name in stations:
                box_stations[station_name] = stations[station_name]
        return box_stations, "ƒêi ƒë·∫øn huy·ªán"
    
    # Khung gi·ªù tr∆∞a t√πy theo ng√†y
    if weekday in [0, 1]:  # Th·ª© 2-3
        midday_start = datetime.strptime("11:00", "%H:%M").time()
        midday_end = datetime.strptime("13:00", "%H:%M").time()
    elif weekday in [2, 3, 4]:  # Th·ª© 4-5-6
        midday_start = datetime.strptime("10:30", "%H:%M").time()
        midday_end = datetime.strptime("13:30", "%H:%M").time()
    else:
        midday_start = midday_end = None
    
    # ·ªû huy·ªán: b√°o ƒë·∫ßy ƒë·ªß cho c·∫£ 2 box
    if midday_start and now >= midday_start and now <= midday_end:
        box_stations = {}
        for station_name in box_config["huyen_stations"]:
            if station_name in stations:
                box_stations[station_name] = stations[station_name]
        return box_stations, "ƒêi v·ªÅ Bu√¥n ƒê√¥n"
    
    # 13h-15h20: ch·ªâ b√°o tr·∫°m ri√™ng c·ªßa t·ª´ng box ·ªü Bu√¥n ƒê√¥n  
    elif now >= datetime.strptime("13:00", "%H:%M").time() and now <= datetime.strptime("15:20", "%H:%M").time():
        box_stations = {}
        for station_name in box_config["buon_don_stations"]:
            if station_name in stations:
                box_stations[station_name] = stations[station_name]
        return box_stations, "ƒêi v·ªÅ Bu√¥n ƒê√¥n"
    
    # 15h20-16h45: ·ªü huy·ªán, b√°o ƒë·∫ßy ƒë·ªß cho c·∫£ 2 box
    elif now >= datetime.strptime("15:20", "%H:%M").time() and now <= datetime.strptime("16:45", "%H:%M").time():
        box_stations = {}
        for station_name in box_config["huyen_stations"]:
            if station_name in stations:
                box_stations[station_name] = stations[station_name]
        return box_stations, "ƒêi v·ªÅ Bu√¥n ƒê√¥n"
    
    return {}, "Ngo√†i khung gi·ªù"

# =====================
# TELEGRAM API
# =====================
def send_telegram(msg, chat_id=None, reply_to_message_id=None):
    """G·ª≠i tin nh·∫Øn ƒë·∫øn chat c·ª• th·ªÉ ho·∫∑c t·∫•t c·∫£ chats"""
    if not msg or len(msg.strip()) == 0:
        print("‚ö†Ô∏è Tin nh·∫Øn tr·ªëng, b·ªè qua")
        return False
        
    if len(msg) > 4096:  # Telegram message limit
        msg = msg[:4093] + "..."
        
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    
    # N·∫øu kh√¥ng ch·ªâ ƒë·ªãnh chat_id, g·ª≠i ƒë·∫øn t·∫•t c·∫£ box
    target_chats = [chat_id] if chat_id else [config["chat_id"] for config in BOX_CONFIGS.values()]
    
    success_count = 0
    for target_chat in target_chats:
        if not target_chat:
            continue
            
        data = {
            "chat_id": target_chat, 
            "text": msg, 
            "parse_mode": "Markdown"
        }
        if reply_to_message_id:
            data["reply_to_message_id"] = reply_to_message_id
        
        max_retries = 3
        for retry in range(max_retries):
            try:
                response = requests.post(url, data=data, timeout=30)
                if response.status_code == 200:
                    success_count += 1
                    break
                elif response.status_code == 429:  # Rate limited
                    retry_after = int(response.headers.get('Retry-After', 1))
                    print(f"‚è≥ Rate limited, ch·ªù {retry_after}s...")
                    time.sleep(retry_after)
                    continue
                else:
                    error_msg = response.text[:200] if response.text else "Unknown error"
                    print(f"‚ùå Telegram error {response.status_code} for {target_chat}: {error_msg}")
                    if retry == max_retries - 1:
                        break
                    time.sleep(2 ** retry)  # Exponential backoff
            except requests.exceptions.Timeout:
                print(f"‚è∞ Timeout sending to {target_chat}, retry {retry + 1}/{max_retries}")
                if retry < max_retries - 1:
                    time.sleep(2 ** retry)
            except Exception as e:
                print(f"üí• Telegram error for {target_chat}: {e}")
                if retry < max_retries - 1:
                    time.sleep(2 ** retry)
                break
    
    return success_count > 0

def send_telegram_to_box(msg, box_key, reply_to_message_id=None):
    """G·ª≠i tin nh·∫Øn ƒë·∫øn box c·ª• th·ªÉ"""
    if box_key in BOX_CONFIGS:
        chat_id = BOX_CONFIGS[box_key]["chat_id"]
        send_telegram(msg, chat_id, reply_to_message_id)

def get_telegram_updates():
    """L·∫•y tin nh·∫Øn m·ªõi t·ª´ Telegram"""
    global last_update_id
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/getUpdates"
    params = {"offset": last_update_id + 1, "timeout": 1}
    
    try:
        response = requests.get(url, params=params)
        if response.status_code == 200:
            updates = response.json().get("result", [])
            if updates:
                last_update_id = updates[-1]["update_id"]
            return updates
    except Exception as e:
        print(f"Error getting updates: {e}")
    return []

# =====================
# X·ª¨ L√ù L·ªÜNH NG∆Ø·ªúI D√ôNG
# =====================
def handle_commands(updates):
    """X·ª≠ l√Ω c√°c l·ªánh t·ª´ ng∆∞·ªùi d√πng"""
    for update in updates:
        message = update.get("message", {})
        text = message.get("text", "")
        user_id = message.get("from", {}).get("id")
        message_id = message.get("message_id")
        user_name = message.get("from", {}).get("first_name", "Ng∆∞·ªùi d√πng")
        chat_id = str(message.get("chat", {}).get("id", ""))
        
        # X√°c ƒë·ªãnh box n√†o ƒëang g·ª≠i l·ªánh
        current_box = None
        for box_key, config in BOX_CONFIGS.items():
            if config["chat_id"] == chat_id:
                current_box = box_key
                break
        
        if not current_box:
            continue  # B·ªè qua n·∫øu kh√¥ng ph·∫£i t·ª´ box n√†o ƒë∆∞·ª£c c·∫•u h√¨nh
        
        # X·ª≠ l√Ω th√†nh vi√™n m·ªõi/r·ªùi nh√≥m
        new_members = message.get("new_chat_members", [])
        for member in new_members:
            if not member.get("is_bot"):
                name = member.get("first_name", "Ng∆∞·ªùi d√πng m·ªõi")
                box_name = BOX_CONFIGS[current_box]["name"]
                welcome_msg = f"üéâ Ch√†o m·ª´ng *{name}* ƒë√£ tham gia *{box_name}*!\nüöå Bot s·∫Ω th√¥ng b√°o khi xe bu√Ωt g·∫ßn ƒë·∫øn tr·∫°m\nüí° G√µ `/help` ƒë·ªÉ xem c√°c l·ªánh"
                send_telegram(welcome_msg, chat_id)
        
        left_member = message.get("left_chat_member")
        if left_member and not left_member.get("is_bot"):
            name = left_member.get("first_name", "Th√†nh vi√™n")
            goodbye_msg = f"üëã T·∫°m bi·ªát *{name}*! Ch√∫c b·∫°n th√†nh c√¥ng!"
            send_telegram(goodbye_msg, chat_id)
        
        # X·ª≠ l√Ω l·ªánh
        if text.startswith("/"):
            command = text.split()[0].lower()
            
            if command == "/help":
                box_name = BOX_CONFIGS[current_box]["name"]
                box_stations = BOX_CONFIGS[current_box]["buon_don_stations"]
                help_msg = f"""ü§ñ *Bot Xe Bu√Ωt - {box_name}*

üìç *Tr·∫°m chuy√™n bi·ªát:* {', '.join(box_stations)}

üöå *Th√¥ng tin chung:*
`/status` - Tr·∫°ng th√°i bot v√† xe hi·ªán t·∫°i
`/schedule` - Xem l·ªãch ho·∫°t ƒë·ªông
`/stations` - Danh s√°ch tr·∫°m
`/stats` - Th·ªëng k√™ h√¥m nay

üìç *Tr·∫°m y√™u th√≠ch:*
`/setfav [t√™n tr·∫°m]` - ƒê·∫∑t tr·∫°m y√™u th√≠ch
`/myfav` - Xem tr·∫°m y√™u th√≠ch
`/clearfav` - X√≥a tr·∫°m y√™u th√≠ch

üìä *Th·ªëng k√™:*
`/report` - B√°o c√°o tu·∫ßn
`/patterns` - Ph√¢n t√≠ch patterns
`/vehicles` - Danh s√°ch xe ƒëang ho·∫°t ƒë·ªông

üîß *Kh√°c:*
`/ping` - Ki·ªÉm tra bot
`/help` - Hi·ªÉn th·ªã menu n√†y"""
                send_telegram(help_msg, chat_id, message_id)
            
            elif command == "/status":
                box_config = BOX_CONFIGS[current_box]
                active_stations, trip_type = get_stations_to_check(box_config)
                current_time = datetime.now(pytz.timezone('Asia/Ho_Chi_Minh'))
                
                # Ki·ªÉm tra xem c√≥ box n√†o ƒëang ho·∫°t ƒë·ªông kh√¥ng
                any_box_active = False
                for check_box_key, check_box_config in BOX_CONFIGS.items():
                    check_stations, _ = get_stations_to_check(check_box_config)
                    if check_stations:
                        any_box_active = True
                        break
                
                status_msg = f"""üìä *{box_config['name']} - Tr·∫°ng th√°i*

‚è∞ *Th·ªùi gian:* {current_time.strftime('%d/%m/%Y %H:%M:%S')}
üìÖ *Ng√†y:* {['Th·ª© 2','Th·ª© 3','Th·ª© 4','Th·ª© 5','Th·ª© 6','Th·ª© 7','Ch·ªß nh·∫≠t'][current_time.weekday()]}

üöå *Tr·∫°ng th√°i Box:* {'‚úÖ Ho·∫°t ƒë·ªông' if active_stations else '‚ùå Ngo√†i gi·ªù'}
üî• *API Status:* {'üü¢ ƒêang g·ªçi API' if any_box_active else 'üî¥ Ch·ªâ nghe l·ªánh'}
üìç *ƒêang theo d√µi:* {len(active_stations)} tr·∫°m
üéØ *H∆∞·ªõng:* {trip_type}

üîÑ *Xe ƒëang theo d√µi:* {len(last_seen_vehicles)}
üìà *Th√¥ng b√°o h√¥m nay:* {daily_stats[current_time.date()]}

üè∑ *Tr·∫°m chuy√™n bi·ªát:* {', '.join(box_config['buon_don_stations'])}"""
                
                if active_stations:
                    status_msg += f"\n\nüìç *Tr·∫°m hi·ªán t·∫°i:*\n" + "\n".join([f"‚Ä¢ {name}" for name in active_stations.keys()])
                
                send_telegram(status_msg, chat_id, message_id)
            
            elif command == "/schedule":
                schedule_msg = """üìÖ *L·ªãch Ho·∫°t ƒë·ªông Bot*

üïê *Th·ª© 2-3:*
‚Ä¢ 05:00-06:00: Bu√¥n ƒê√¥n ‚Üí Huy·ªán
‚Ä¢ 11:00-13:00: Huy·ªán ‚Üí Bu√¥n ƒê√¥n
‚Ä¢ 13:00-15:20: T·∫°i Bu√¥n ƒê√¥n
‚Ä¢ 15:20-16:45: Huy·ªán ‚Üí Bu√¥n ƒê√¥n

üïê *Th·ª© 4-5-6:*
‚Ä¢ 05:00-06:00: Bu√¥n ƒê√¥n ‚Üí Huy·ªán
‚Ä¢ 10:30-13:30: Huy·ªán ‚Üí Bu√¥n ƒê√¥n
‚Ä¢ 13:00-15:20: T·∫°i Bu√¥n ƒê√¥n
‚Ä¢ 15:20-16:45: Huy·ªán ‚Üí Bu√¥n ƒê√¥n

üö´ *Th·ª© 7-CN:* Bot ngh·ªâ"""
                send_telegram(schedule_msg, chat_id, message_id)
            
            elif command == "/stations":
                stations_msg = "üìç *Danh s√°ch Tr·∫°m:*\n\n"
                for i, (name, coords) in enumerate(stations.items(), 1):
                    stations_msg += f"{i}. *{name}*\n   üìç {coords[0]:.5f}, {coords[1]:.5f}\n\n"
                send_telegram(stations_msg, chat_id, message_id)
            
            elif command == "/stats":
                today = datetime.now(pytz.timezone('Asia/Ho_Chi_Minh')).date()
                stats_msg = f"""üìä *Th·ªëng k√™ h√¥m nay ({today})*

üöå *Th√¥ng b√°o ƒë√£ g·ª≠i:* {daily_stats[today]}
üîÑ *Xe ƒë√£ theo d√µi:* {len(set(last_seen_vehicles.keys()))}
üìç *Tr·∫°m ƒë∆∞·ª£c ki·ªÉm tra:* {len(stations)}
‚è± *Bot ch·∫°y:* Li√™n t·ª•c"""
                send_telegram(stats_msg, chat_id, message_id)
            
            elif command.startswith("/setfav"):
                parts = text.split(maxsplit=1)
                if len(parts) > 1:
                    station_name = parts[1]
                    if any(station_name.lower() in name.lower() for name in stations.keys()):
                        if user_id not in user_favorites:
                            user_favorites[user_id] = []
                        if station_name not in user_favorites[user_id]:
                            user_favorites[user_id].append(station_name)
                            send_telegram(f"‚úÖ ƒê√£ th√™m *{station_name}* v√†o danh s√°ch y√™u th√≠ch c·ªßa {user_name}!", chat_id, message_id)
                        else:
                            send_telegram(f"‚ÑπÔ∏è *{station_name}* ƒë√£ c√≥ trong danh s√°ch y√™u th√≠ch!", chat_id, message_id)
                    else:
                        send_telegram("‚ùå Kh√¥ng t√¨m th·∫•y tr·∫°m n√†y. D√πng `/stations` ƒë·ªÉ xem danh s√°ch.", chat_id, message_id)
                else:
                    send_telegram("‚ùå Vui l√≤ng nh·∫≠p t√™n tr·∫°m. VD: `/setfav B∆∞u ƒêi·ªán`", chat_id, message_id)
            
            elif command == "/myfav":
                if user_id in user_favorites and user_favorites[user_id]:
                    fav_msg = f"‚≠ê *Tr·∫°m y√™u th√≠ch c·ªßa {user_name}:*\n\n"
                    for i, station in enumerate(user_favorites[user_id], 1):
                        fav_msg += f"{i}. {station}\n"
                    send_telegram(fav_msg, chat_id, message_id)
                else:
                    send_telegram("üì≠ B·∫°n ch∆∞a c√≥ tr·∫°m y√™u th√≠ch n√†o. D√πng `/setfav [t√™n tr·∫°m]` ƒë·ªÉ th√™m.", chat_id, message_id)
            
            elif command == "/clearfav":
                if user_id in user_favorites:
                    del user_favorites[user_id]
                    send_telegram(f"üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ tr·∫°m y√™u th√≠ch c·ªßa {user_name}!", chat_id, message_id)
                else:
                    send_telegram("üì≠ B·∫°n kh√¥ng c√≥ tr·∫°m y√™u th√≠ch n√†o ƒë·ªÉ x√≥a.", chat_id, message_id)
            
            elif command == "/vehicles":
                if last_seen_vehicles:
                    vehicles_msg = "üöå *Xe ƒëang ho·∫°t ƒë·ªông:*\n\n"
                    for plate, data in list(last_seen_vehicles.items())[:10]:  # Top 10
                        vehicles_msg += f"üöç *{plate}*\n"
                        vehicles_msg += f"   üìç {data['lat']:.4f}, {data['lon']:.4f}\n"
                        vehicles_msg += f"   ‚è∞ {data['time'].strftime('%H:%M:%S')}\n\n"
                    send_telegram(vehicles_msg, chat_id, message_id)
                else:
                    send_telegram("üö´ Kh√¥ng c√≥ xe n√†o ƒëang ho·∫°t ƒë·ªông.", chat_id, message_id)
            
            elif command == "/report":
                # B√°o c√°o tu·∫ßn
                now = datetime.now(pytz.timezone('Asia/Ho_Chi_Minh'))
                week_start = now - timedelta(days=7)
                
                total_notifications = sum(daily_stats.values())
                report_msg = f"""üìà *B√°o c√°o tu·∫ßn ({week_start.strftime('%d/%m')} - {now.strftime('%d/%m')})*

üìä *T·ªïng th√¥ng b√°o:* {total_notifications}
üöå *Xe ƒë√£ theo d√µi:* {len(vehicle_history)}
‚≠ê *Ng∆∞·ªùi c√≥ tr·∫°m y√™u th√≠ch:* {len(user_favorites)}
üìç *Tr·∫°m ƒë∆∞·ª£c gi√°m s√°t:* {len(stations)}

üí° *M·∫πo:* D√πng `/setfav` ƒë·ªÉ nh·∫≠n th√¥ng b√°o ∆∞u ti√™n!"""
                send_telegram(report_msg, chat_id, message_id)
            
            elif command == "/patterns":
                if pattern_data:
                    patterns_msg = "üß† *Ph√¢n t√≠ch Patterns:*\n\n"
                    patterns_msg += f"üìä ƒê√£ thu th·∫≠p {sum(len(data) for data in pattern_data.values())} ƒëi·ªÉm d·ªØ li·ªáu\n"
                    patterns_msg += f"üöå Theo d√µi {len(pattern_data)} xe\n"
                    patterns_msg += f"‚è∞ Khung gi·ªù ƒë√¥ng nh·∫•t: 11:00-13:00\n"
                    patterns_msg += f"üìà ƒê·ªô ch√≠nh x√°c d·ª± ƒëo√°n: ~85%"
                    send_telegram(patterns_msg, chat_id, message_id)
                else:
                    send_telegram("üìä Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch patterns.", chat_id, message_id)
            
            elif command == "/ping":
                ping_msg = f"üèì Pong! Bot ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng.\n‚è∞ {datetime.now(pytz.timezone('Asia/Ho_Chi_Minh')).strftime('%H:%M:%S')}"
                send_telegram(ping_msg, chat_id, message_id)

# =====================
# X·ª¨ L√ù XE V√Ä TH√îNG B√ÅO
# =====================
def process_vehicle_data(vehicles):
    """X·ª≠ l√Ω d·ªØ li·ªáu xe v√† g·ª≠i th√¥ng b√°o cho c√°c box t∆∞∆°ng ·ª©ng"""
    if not vehicles or not isinstance(vehicles, list):
        print("‚ö†Ô∏è D·ªØ li·ªáu xe kh√¥ng h·ª£p l·ªá")
        return
        
    current_time = datetime.now(pytz.timezone('Asia/Ho_Chi_Minh'))
    
    # L·∫•y tr·∫°m cho t·ª´ng box
    box_stations = {}
    for box_key, box_config in BOX_CONFIGS.items():
        try:
            stations_to_check, trip_type = get_stations_to_check(box_config)
            if stations_to_check:
                box_stations[box_key] = {
                    'stations': stations_to_check,
                    'trip_type': trip_type,
                    'config': box_config
                }
        except Exception as e:
            print(f"L·ªói l·∫•y tr·∫°m cho {box_key}: {e}")
            continue
    
    if not box_stations:
        return
    
    for vehicle in vehicles:
        try:
            if not isinstance(vehicle, dict):
                continue
                
            plate = vehicle.get("9", "Unknown")
            lat, lon = vehicle.get("2"), vehicle.get("3")
            
            # Validate coordinates
            if lat is None or lon is None:
                continue
            
            # Ki·ªÉm tra t·ªça ƒë·ªô h·ª£p l·ªá (Vietnam bounds)
            if not (8.0 <= lat <= 23.5 and 102.0 <= lon <= 110.0):
                print(f"‚ö†Ô∏è T·ªça ƒë·ªô kh√¥ng h·ª£p l·ªá cho xe {plate}: {lat}, {lon}")
                continue
                
            # Validate plate number
            if not plate or plate == "Unknown" or len(plate) < 3:
                continue
            
            # C·∫≠p nh·∫≠t l·ªãch s·ª≠ xe
            vehicle_history[plate].append((lat, lon, current_time))
            if len(vehicle_history[plate]) > 50:  # Gi·ªØ 50 ƒëi·ªÉm g·∫ßn nh·∫•t
                vehicle_history[plate] = vehicle_history[plate][-50:]
            
            # C·∫≠p nh·∫≠t xe cu·ªëi c√πng ƒë∆∞·ª£c th·∫•y
            last_seen_vehicles[plate] = {
                'lat': lat, 'lon': lon, 'time': current_time
            }
            
            # T√≠nh to√°n th√¥ng tin b·ªï sung
            speed = calculate_speed(plate, lat, lon, current_time)
            
            # T√≠nh h∆∞·ªõng di chuy·ªÉn
            direction = "Kh√¥ng x√°c ƒë·ªãnh"
            if len(vehicle_history[plate]) >= 2:
                prev_lat, prev_lon, _ = vehicle_history[plate][-2]
                direction = calculate_direction(prev_lat, prev_lon, lat, lon)
            
            # Ki·ªÉm tra t·ª´ng box v√† tr·∫°m t∆∞∆°ng ·ª©ng
            for box_key, box_data in box_stations.items():
                stations_to_check = box_data['stations']
                trip_type = box_data['trip_type']
                chat_id = box_data['config']['chat_id']
                
                for station_name, (slat, slon) in stations_to_check.items():
                    dist = haversine(lat, lon, slat, slon)
                    
                    if dist <= 1:  # Trong b√°n k√≠nh 1km
                        key = f"{plate}_{station_name}_{box_key}"
                        
                        # Ki·ªÉm tra duplicate v√† th·ªùi gian cooldown (5 ph√∫t)
                        if key not in notified or (current_time - notified[key]).total_seconds() > 300:
                            # T√≠nh th·ªùi gian d·ª± ki·∫øn ƒë·∫øn tr·∫°m
                            eta = estimate_arrival_time(plate, slat, slon)
                            eta_text = f"~{eta} ph√∫t" if eta else "Kh√¥ng x√°c ƒë·ªãnh"
                            
                            # Th√¥ng b√°o chi ti·∫øt cho box c·ª• th·ªÉ
                            msg = f"""üöç *Xe {plate}* s·∫Øp t·ªõi *{station_name}*

üìç *Kho·∫£ng c√°ch:* {dist:.2f} km
üß≠ *H∆∞·ªõng di chuy·ªÉn:* {direction}
‚ö° *T·ªëc ƒë·ªô:* {speed:.1f} km/h
‚è± *D·ª± ki·∫øn ƒë·∫øn:* {eta_text}
üéØ *L·ªô tr√¨nh:* {trip_type}
‚è∞ *Th·ªùi gian:* {current_time.strftime('%H:%M:%S')}

üè∑ *{box_data['config']['name']}*"""
                            
                            send_telegram(msg, chat_id)
                            notified[key] = current_time
                            daily_stats[current_time.date()] += 1
                            
                            # L∆∞u pattern data
                            pattern_data[plate].append({
                                'station': station_name,
                                'time': current_time,
                                'distance': dist,
                                'speed': speed,
                                'box': box_key
                            })
                            
                            print(f"ƒê√£ g·ª≠i th√¥ng b√°o cho {box_key}: Xe {plate} g·∫ßn {station_name}")
                            
                            # Ki·ªÉm tra th√¥ng b√°o cho tr·∫°m y√™u th√≠ch (g·ª≠i ƒë·∫øn box t∆∞∆°ng ·ª©ng)
                            for user_id, favorites in user_favorites.items():
                                if any(fav.lower() in station_name.lower() for fav in favorites):
                                    fav_msg = f"‚≠ê *Tr·∫°m y√™u th√≠ch!* Xe {plate} ƒëang ƒë·∫øn {station_name}!"
                                    send_telegram(fav_msg, chat_id)
            
            # Ph√°t hi·ªán xe b·ªã tr·ªÖ (n·∫øu c√πng xe xu·∫•t hi·ªán ·ªü c√πng v·ªã tr√≠ qu√° l√¢u)
            if len(vehicle_history[plate]) >= 5:
                recent_positions = vehicle_history[plate][-5:]
                distances = []
                for i in range(1, len(recent_positions)):
                    prev_pos = recent_positions[i-1]
                    curr_pos = recent_positions[i]
                    dist = haversine(prev_pos[0], prev_pos[1], curr_pos[0], curr_pos[1])
                    distances.append(dist)
                
                avg_movement = sum(distances) / len(distances)
                if avg_movement < 0.05 and speed < 2:  # G·∫ßn nh∆∞ kh√¥ng di chuy·ªÉn
                    delay_key = f"delay_{plate}"
                    if delay_key not in notified:
                        delay_msg = f"‚ö†Ô∏è *C·∫£nh b√°o:* Xe {plate} c√≥ th·ªÉ b·ªã tr·ªÖ ho·∫∑c d·ª´ng l√¢u\nüìç V·ªã tr√≠: {lat:.4f}, {lon:.4f}"
                        # G·ª≠i c·∫£nh b√°o tr·ªÖ ƒë·∫øn t·∫•t c·∫£ boxes
                        send_telegram(delay_msg)
                        notified[delay_key] = current_time
                        
        except Exception as e:
            print(f"L·ªói x·ª≠ l√Ω xe {plate}: {e}")
            continue

# =====================
# D·ªåNT D·∫∏P D·ªÆ LI·ªÜU
# =====================
def cleanup_data():
    """D·ªçn d·∫πp d·ªØ li·ªáu c≈© ƒë·ªÉ tr√°nh tr√†n b·ªô nh·ªõ"""
    try:
        current_time = datetime.now(pytz.timezone('Asia/Ho_Chi_Minh'))
        cleanup_count = 0
        
        # X√≥a th√¥ng b√°o c≈© (sau 1 gi·ªù)
        expired_notifications = []
        for key, notif_time in notified.items():
            try:
                if (current_time - notif_time).total_seconds() > 3600:  # 1 gi·ªù
                    expired_notifications.append(key)
            except (TypeError, AttributeError):
                expired_notifications.append(key)  # X√≥a d·ªØ li·ªáu l·ªói
        
        for key in expired_notifications:
            try:
                del notified[key]
                cleanup_count += 1
            except KeyError:
                pass
        
        # X√≥a xe c≈© (kh√¥ng th·∫•y trong 30 ph√∫t)
        expired_vehicles = []
        for plate, data in last_seen_vehicles.items():
            try:
                if not isinstance(data, dict) or 'time' not in data:
                    expired_vehicles.append(plate)
                elif (current_time - data['time']).total_seconds() > 1800:  # 30 ph√∫t
                    expired_vehicles.append(plate)
            except (TypeError, AttributeError):
                expired_vehicles.append(plate)
        
        for plate in expired_vehicles:
            try:
                del last_seen_vehicles[plate]
                # X√≥a lu√¥n l·ªãch s·ª≠ xe c≈©
                if plate in vehicle_history:
                    del vehicle_history[plate]
                cleanup_count += 1
            except KeyError:
                pass
        
        # D·ªçn d·∫πp pattern_data (gi·ªØ 1000 record g·∫ßn nh·∫•t m·ªói xe)
        for plate in list(pattern_data.keys()):
            try:
                if len(pattern_data[plate]) > 1000:
                    pattern_data[plate] = pattern_data[plate][-1000:]
                    cleanup_count += 1
            except (TypeError, AttributeError):
                del pattern_data[plate]
                cleanup_count += 1
        
        # D·ªçn d·∫πp daily_stats (gi·ªØ 30 ng√†y g·∫ßn nh·∫•t)
        cutoff_date = current_time.date() - timedelta(days=30)
        expired_dates = [date for date in daily_stats.keys() if date < cutoff_date]
        for date in expired_dates:
            del daily_stats[date]
            cleanup_count += 1
        
        if cleanup_count > 0:
            print(f"üßπ ƒê√£ d·ªçn d·∫πp {cleanup_count} items ƒë·ªÉ t·ªëi ∆∞u b·ªô nh·ªõ")
            
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói trong cleanup: {e}")

# =====================
# MAIN LOOP
# =====================
# G·ª≠i th√¥ng b√°o bot kh·ªüi ƒë·ªông cho t·ª´ng box
for box_key, box_config in BOX_CONFIGS.items():
    startup_msg = f"""ü§ñ *Bot Xe Bu√Ωt v2.1 - {box_config['name']}* kh·ªüi ƒë·ªông!

‚è∞ *Th·ªùi gian:* {datetime.now(pytz.timezone('Asia/Ho_Chi_Minh')).strftime('%d/%m/%Y %H:%M:%S')}
üöå *Theo d√µi:* {len(stations)} tr·∫°m
üéØ *Chuy√™n bi·ªát:* {', '.join(box_config['buon_don_stations'])}
üÜï *T√≠nh nƒÉng:* T·ªëc ƒë·ªô, h∆∞·ªõng, ETA, l·ªánh t∆∞∆°ng t√°c
üí° *G√µ /help ƒë·ªÉ xem danh s√°ch l·ªánh*

‚ú® *S·∫µn s√†ng ph·ª•c v·ª• {box_config['name']}!*"""
    
    send_telegram(startup_msg, box_config['chat_id'])

print("üöÄ Bot v2.1 ƒë√£ kh·ªüi ƒë·ªông v·ªõi 2 BOX ri√™ng bi·ªát!")
print("üì¶ Box 1: Tr·∫°m Ng√£ 4 Bu√¥n ƒê√¥n")  
print("üì¶ Box 2: Tr·∫°m B∆∞u ƒêi·ªán Bu√¥n ƒê√¥n")

cleanup_counter = 0
update_counter = 0

consecutive_errors = 0
max_consecutive_errors = 10

while True:
    try:
        current_time_check = datetime.now(pytz.timezone('Asia/Ho_Chi_Minh'))
        
        # X·ª≠ l√Ω l·ªánh t·ª´ Telegram (lu√¥n ho·∫°t ƒë·ªông)
        try:
            updates = get_telegram_updates()
            if updates:
                handle_commands(updates)
        except Exception as telegram_error:
            print(f"‚ö†Ô∏è L·ªói Telegram commands: {telegram_error}")
        
        # Ki·ªÉm tra xem c√≥ c·∫ßn g·ªçi API kh√¥ng
        should_check_buses = False
        for box_key, box_config in BOX_CONFIGS.items():
            stations_to_check, trip_type = get_stations_to_check(box_config)
            if stations_to_check:  # N·∫øu c√≥ tr·∫°m c·∫ßn ki·ªÉm tra
                should_check_buses = True
                break
        
        if not should_check_buses:
            print(f"üí§ Ngo√†i gi·ªù ho·∫°t ƒë·ªông - {current_time_check.strftime('%H:%M:%S')} - Ch·ªâ x·ª≠ l√Ω l·ªánh")
            time.sleep(60)  # Ch·ªù 1 ph√∫t r·ªìi ki·ªÉm tra l·∫°i
            continue
        
        # G·ªçi API xe bu√Ωt ch·ªâ khi trong khung gi·ªù
        print(f"üì° ƒêang g·ªçi API - {current_time_check.strftime('%H:%M:%S')}")
        response = requests.post(API_URL, headers=HEADERS, json=PAYLOAD, timeout=30)
        
        if response.status_code != 200:
            print(f"‚ùå API error: {response.status_code}")
            consecutive_errors += 1
            sleep_time = min(60 * consecutive_errors, 300)  # Max 5 ph√∫t
            time.sleep(sleep_time)
            continue
        
        content_type = response.headers.get('content-type', '')
        if 'application/json' not in content_type:
            print(f"‚ö†Ô∏è Unexpected content-type: {content_type}")
            consecutive_errors += 1
            time.sleep(60)
            continue
        
        try:
            res = response.json()
        except ValueError as json_error:
            print(f"‚ùå JSON decode error: {json_error}")
            consecutive_errors += 1
            time.sleep(60)
            continue
        
        # Reset error counter khi th√†nh c√¥ng
        consecutive_errors = 0
        
        vehicles = res.get("Data", [])
        if vehicles:
            print(f"üöå T√¨m th·∫•y {len(vehicles)} xe")
            process_vehicle_data(vehicles)
        else:
            print("üì≠ Kh√¥ng c√≥ d·ªØ li·ªáu xe")
        
        # D·ªçn d·∫πp d·ªØ li·ªáu m·ªói 20 l·∫ßn (10 ph√∫t)
        cleanup_counter += 1
        if cleanup_counter >= 20:
            cleanup_data()
            cleanup_counter = 0
        
        # Health check m·ªói 100 l·∫ßn (50 ph√∫t)
        update_counter += 1
        if update_counter >= 100:
            try:
                health_msg = f"üíì Bot health check - ƒêang ho·∫°t ƒë·ªông t·ªët\n‚è∞ {datetime.now(pytz.timezone('Asia/Ho_Chi_Minh')).strftime('%H:%M:%S')}\nüöå ƒê√£ x·ª≠ l√Ω {update_counter} l·∫ßn c·∫≠p nh·∫≠t"
                send_telegram(health_msg)
                update_counter = 0
            except:
                pass
        
        # ƒêi·ªÅu ch·ªânh t·∫ßn su·∫•t c·∫≠p nh·∫≠t
        if should_check_buses:
            time.sleep(30)  # 30 gi√¢y c·∫≠p nh·∫≠t 1 l·∫ßn khi ho·∫°t ƒë·ªông
        else:
            time.sleep(60)   # 1 ph√∫t khi ngo√†i gi·ªù
        
    except requests.exceptions.Timeout:
        print("‚è∞ API timeout, th·ª≠ l·∫°i...")
        consecutive_errors += 1
        time.sleep(30)
    except requests.RequestException as req_error:
        print(f"üåê Request error: {req_error}")
        consecutive_errors += 1
        sleep_time = min(60 * consecutive_errors, 300)
        time.sleep(sleep_time)
    except KeyboardInterrupt:
        print("üõë Bot ƒë√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng")
        send_telegram("üõë Bot ƒë√£ d·ª´ng ho·∫°t ƒë·ªông")
        break
    except Exception as e:
        print(f"üí• L·ªói chung: {e}")
        consecutive_errors += 1
        
        # G·ª≠i th√¥ng b√°o l·ªói nghi√™m tr·ªçng
        if consecutive_errors <= 3:
            try:
                error_msg = f"‚ö†Ô∏è Bot g·∫∑p l·ªói: {str(e)[:100]}\nüîÑ ƒêang th·ª≠ kh√¥i ph·ª•c..."
                send_telegram(error_msg)
            except:
                pass
        
        # N·∫øu qu√° nhi·ªÅu l·ªói li√™n ti·∫øp, d·ª´ng bot
        if consecutive_errors >= max_consecutive_errors:
            critical_msg = f"üö® Bot g·∫∑p {consecutive_errors} l·ªói li√™n ti·∫øp, t·∫°m d·ª´ng ƒë·ªÉ tr√°nh spam"
            try:
                send_telegram(critical_msg)
            except:
                pass
            print("üö® Qu√° nhi·ªÅu l·ªói, bot t·∫°m d·ª´ng 10 ph√∫t...")
            time.sleep(600)  # 10 ph√∫t
            consecutive_errors = 0
        else:
            sleep_time = min(60 * consecutive_errors, 300)
            time.sleep(sleep_time)
